# 内存对齐
计算机中内存的地址空间是按照 byte 来划分的，从理论上讲对任何类型变量的访问可以从内存中的任意地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。编译器将程序中的每个 **数据单元** 的地址安排在机器字的整数倍的地址指向的内存之中。
# 为什么要内存对齐：
主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。比如 32 位 CPU，机器字长为 4 字节，数据总线宽度为 32 位，如果该 CPU 的地址总线宽度也是为32 位，则其可以访问的地址空间为 [0,0xffffffff]内存对齐的主要目的是为了减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。假设读取 8 个字节的数据，按照每次读取 4 个字节的速度，则 8 个字节需要 CPU 耗费 2 次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。
除了能够减少内存访问次数，增加内存读取的吞吐量以外，还有其他原因：
- 特定硬件设备只支持存取对齐数据，存取非对齐数据会引发异常，比如SIMD指令要求内存严格对齐
- 要求每次内存访问都是原子操作，如果变量的大小不超过机器字长，那内存对齐之后对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候是原子操作，此时CPU就需要多次读取内存，破坏了变量的原子性
- 提高内存的访存效率
- 部分处理器虽然支持非对齐数据的访问，但会引发对齐trap（alignment trap）

# 对齐原则：
- 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。
- 结构体作为成员:**如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.**(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。
- 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。
- sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。
- 结构体中的 static 成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域；
- 
```
class Data
{
    char c;
    int a;
    char d;
};
 
cout << sizeof(Data) << endl;
// 12
```

```
class Data
{
    char c;
    char d;
    int a;
};
 
cout << sizeof(Data) << endl;
// 8
```
class中的数据成员放入内存的时候，内存拿出一个内存块来，数据成员们排队一个一个往里放，遇到太大的，不是把自己劈成两半，能放多少放多少，而是等下一个内存块过来。这样的话，就可以理解为什么如上两个的代码输出结果不一样了，因为上边是1+（3）+4+1+（3）=12，而下边是1+1+（2）+4=8。括号中为补齐的bytes。

```
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    int integer;
    double d;
};
 
cout << sizeof(Data) << endl;
// 48
```

```
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    double d;
};
 
cout << sizeof(Data) << endl;
// 48
```
在默认条件下，内存对齐是以class中最大的那个基本类型为基准的，如果class中有自定义类型，则递归的取其中最大的基本类型来参与比较。在No.5和No.6中内存块一个接一个的过来接走数据成员，一直到第5块的时候，BigData里只剩1个char了，将它放入内存块中，内存块还剩7个bytes，接下来是个int（4bytes），能够放下，所以也进入第5~8个内存块，这时候内存块还剩3bytes，而接下来是个double（8bytes），放不下，所以要等下一个内存快到来。因此，No.5的Data的size=33+4+（3）+8=48，同理No.6应该是33+（7）+8=48。
# 指定程序对齐规则：
我们可以指定结构体的对齐规则，在某些特定场景下我们需要指定结构体内存进行对齐，比如在发送特定网络协议报文、硬件协议控制、消息传递、硬件寄存器访问时，这时就就需要避免内存对齐，因为双方均按照预先定义的消息格式来进行交互，从而避免不同的硬件平台造成的差异，同时能够将双方传递的数据进行空间压缩，避免不必要的空间浪费。
programpack: 我们可以用 #progma pack(x) 指定结构体以 x 为单位进行对齐。一般情况下我们可以使用如下：
每个特定平台上的编译器都有自己的默认“对齐系数”(也叫对齐模数)。可通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是你要指定的“对齐系数”。

```
#pragma pack(n)  // 设置对齐字节数为 n（n 通常为 1, 2, 4, 8...）
// 结构体定义
#pragma pack()   // 恢复默认对齐
```

```
#pragma pack(1)    /*将对齐位数强制定位1*/
struct node{
  char f_1byte;
  int e_4byte;
  short int a_2byte;
  char b_1byte;
};
struct node n;
printf("%d\n",sizeof(n)); /*输出结果8*/

```
临时保存/恢复对齐状态：

```
#pragma pack(push, 4)  // 保存当前对齐状态，并设置为4字节对齐
struct S { /* ... */ };
#pragma pack(pop)      // 恢复之前保存的状态
```
查看当前对齐（部分编译器支持）：

```
#pragma pack(show)     // 编译时在警告信息中显示当前对齐值（如MSVC）[^2]
```
替代方案：C11标准引入 _Alignas 关键字，可替代部分场景。
# attribute((aligned(n)))介绍

```
__attribute__((aligned(n)))
__attribute__((packed))
```
（1）attribute((aligned(n)))：它的作用是对结构体整体进行n（n必须是2的幂）字节对齐，而不是为结构体成员进行对齐（使用结构体成员最大占用字节和指定字节对齐大小中最大的那个作为对齐标准）。它可以针对某个结构体进行对齐，也可以写在外部，对其后面的所有变量进行对齐操作
（2）attribute((packed))：按照1字节对齐（取消对齐）
# attribute((aligned(n)))和#pragma pack(n)的区别
## 1. 核心作用对象不同
### pragma pack(n)
控制结构体/联合体内部成员的对齐方式，影响**成员之间**的填充字节。
全局性（影响后续所有定义）
```
#pragma pack(1)       // 设置成员对齐为1字节
struct Example {
    char a;           // 偏移地址 0
    int b;            // 偏移地址 1（无填充）
};                    // 总大小 = 5 字节
```
作用：减少成员间的填充，节省内存
### __attribute__((aligned(n)))
控制整个结构体/变量的内存分配对齐方式，影响**起始地址和总大小**。
局部性（仅修饰声明对象）
```
struct S {
    char a;
    int b;
} __attribute__((aligned(8));  // 结构体按8字节对齐
```
作用：确保结构体起始地址是 n 的倍数，且总大小是 n 的整数倍
## 2. 对齐规则差异
特性	   #pragma pack(n)	__attribute__((aligned(n)))
对齐目标	结构体成员间的偏移地址	整个结构体/变量的起始地址
大小影响	可能减小结构体大小（减少填充）	可能增大结构体大小（尾部填充至 n 倍数）
成员偏移计算	偏移 = min(n, 成员大小) 的倍数	不直接影响成员偏移
结构体总大小规则	总大小 = min(n, 最大成员大小) 的倍数	总大小 = n 的整数倍
作用范围	影响后续所有结构体，直到 #pragma pack()	仅作用于被声明的特定结构体或变量

#pragma pack(n)：优化内存布局，减少填充，适用于内存敏感场景。
__attribute__((aligned(n)))：强制地址对齐，满足硬件或性能需求。

# alignof: 
C++ 11 以后新增 alignof 的特性，通过调用 alignof 返回当前变量的字节对齐方式。比如以下程序：

```
#include <stdio.h>

struct MyStruct {
    char a;
    int b;
};

int main() {
    printf("int 类型的对齐要求：%zu\n", __alignof__(int));
    printf("结构体 MyStruct 的对齐要求：%zu\n", __alignof__(struct MyStruct));
    return 0;
}
```
主要功能
- 确定内存对齐要求：例如，__alignof__(int) 通常会返回 4，表示 int 类型在大多数平台上需要 4 字节对齐。
- 编译期常量计算：alignof 的结果是在编译时就确定的，因此可以用于编译期的常量表达式中。
- 低级内存操作：在进行内存分配、结构体布局优化、或系统底层编程时，了解数据的对齐要求非常重要，可以帮助避免未对齐访问带来的性能问题或硬件异常。
