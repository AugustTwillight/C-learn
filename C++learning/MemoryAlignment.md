# 内存对齐
计算机中内存的地址空间是按照 byte 来划分的，从理论上讲对任何类型变量的访问可以从内存中的任意地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。编译器将程序中的每个 **数据单元** 的地址安排在机器字的整数倍的地址指向的内存之中。
# 为什么要内存对齐：
主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，实际机器字长由 CPU 数据总线宽度决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 可以从内存中读取数据总线宽度的数据，并将其写入到 CPU 的通用寄存器中。比如 32 位 CPU，机器字长为 4 字节，数据总线宽度为 32 位，如果该 CPU 的地址总线宽度也是为32 位，则其可以访问的地址空间为 [0,0xffffffff]内存对齐的主要目的是为了减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。假设读取 8 个字节的数据，按照每次读取 4 个字节的速度，则 8 个字节需要 CPU 耗费 2 次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。
除了能够减少内存访问次数，增加内存读取的吞吐量以外，还有其他原因：
- 特定硬件设备只支持存取对齐数据，存取非对齐数据会引发异常，比如SIMD指令要求内存严格对齐
- 要求每次内存访问都是原子操作，如果变量的大小不超过机器字长，那内存对齐之后对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候是原子操作，此时CPU就需要多次读取内存，破坏了变量的原子性
- 提高内存的访存效率
- 部分处理器虽然支持非对齐数据的访问，但会引发对齐trap（alignment trap）

# 对齐原则：
- 数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。
- 结构体作为成员:**如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储.**(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。
- 收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的"最宽基本类型成员"的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。
- sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。
- 结构体中的 static 成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域；
- 
```
class Data
{
    char c;
    int a;
    char d;
};
 
cout << sizeof(Data) << endl;
// 12
```

```
class Data
{
    char c;
    char d;
    int a;
};
 
cout << sizeof(Data) << endl;
// 8
```
class中的数据成员放入内存的时候，内存拿出一个内存块来，数据成员们排队一个一个往里放，遇到太大的，不是把自己劈成两半，能放多少放多少，而是等下一个内存块过来。这样的话，就可以理解为什么如上两个的代码输出结果不一样了，因为上边是1+（3）+4+1+（3）=12，而下边是1+1+（2）+4=8。括号中为补齐的bytes。

```
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    int integer;
    double d;
};
 
cout << sizeof(Data) << endl;
// 48
```

```
class BigData
{
    char array[33];
};
 
class Data
{
    BigData bd;
    double d;
};
 
cout << sizeof(Data) << endl;
// 48
```
在默认条件下，内存对齐是以class中最大的那个基本类型为基准的，如果class中有自定义类型，则递归的取其中最大的基本类型来参与比较。在No.5和No.6中内存块一个接一个的过来接走数据成员，一直到第5块的时候，BigData里只剩1个char了，将它放入内存块中，内存块还剩7个bytes，接下来是个int（4bytes），能够放下，所以也进入第5~8个内存块，这时候内存块还剩3bytes，而接下来是个double（8bytes），放不下，所以要等下一个内存快到来。因此，No.5的Data的size=33+4+（3）+8=48，同理No.6应该是33+（7）+8=48。
